// http://rodgert.github.io/2014/09/09/type-driven-wire-protocols-with-boost-fusion-pt1/
// https://github.com/rodgert/fusion_samples

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <cassert>
#include <iostream>
#include <numeric>
#include <limits>
#include <type_traits>
#include <tuple>

#include <arpa/inet.h>

#include "boost/asio/buffer.hpp"
#include "boost/fusion/include/define_struct.hpp"
#include "boost/fusion/include/for_each.hpp"
#include "boost/range/has_range_iterator.hpp"

// ---------------------------------------------------------------------------
// ネットワーク・バイトからホスト・バイトへの変換。
template<class T> T ntoh(T) = delete; // white list方式。
uint32_t ntoh(uint32_t v) { return ntohl(v); }
uint16_t ntoh(uint16_t v) { return ntohs(v); }
uint8_t  ntoh(uint8_t  v) { return v; }
int8_t   ntoh(int8_t   v) { return v; }
char     ntoh(char     v) { return v; }

// ホスト・バイトからネットワーク・バイトへの変換。
template<class T> T hton(T) = delete;
uint32_t hton(uint32_t v) { return htonl(v); }
uint16_t hton(uint16_t v) { return htons(v); }
uint8_t  hton(uint8_t  v) { return v; }
int8_t   hton(int8_t   v) { return v; }
char     hton(char     v) { return v; }
// ----------------------------------------------------------------------------

template <typename T>
auto underlying_type_cast(const T& t) ->
    typename std::enable_if<std::is_enum<T>::value, typename std::underlying_type<T>::type>::type {
    return static_cast<typename std::underlying_type<T>::type>(t);
}

// -------------------------------- Deserialize用 -------------------------------------------------
// Visitor(reader)パターン。メンバ変数をbufferから読み取った値で埋める。
struct reader {
    mutable boost::asio::const_buffer m_buf; // visitorのoperator()がconstでなければいけないので。

    explicit reader(boost::asio::const_buffer buf)
        : m_buf(std::move(buf))
        {}

    // 整数型用(uint32_t等)
    template <typename T>
    auto operator()(T& val) const
        -> typename std::enable_if<std::is_integral<T>::value>::type { // SFINAE(Substitution Failure is Not An Error)
        val = ntoh(*boost::asio::buffer_cast<const T*>(m_buf)); // 値を読み込む。
        m_buf = m_buf + sizeof(T);// バッファのポインタを読み込んだ分だけずらす。
    }

    // enum用。C++11のenum classは整数型へ暗黙の変換はしない。
    template <typename T>
    auto operator()(T& val) const
        -> typename std::enable_if<std::is_enum<T>::value>::type {
        typename std::underlying_type<T>::type v;
        (*this)(v); // underlying_type用のoperator()の呼出し。
        val = static_cast<T>(v);
    }

    // std::integral_constant用(コンパイル時整数値を表現する型)
    template <typename T, T v> // テンプレート・パラメータは型以外に値も取れる。
    void operator()(std::integral_constant<T, v>) const { // オブジェクトではなく型情報だけなことに注意。用途は解説。
        using type = std::integral_constant<T, v>;
        typename type::value_type val;
        (*this)(val);
        if(val != type::value){
            throw std::runtime_error("unknown value" + std::to_string(val));
        }
    }

    // これ以下は可変長のデータ型。

    // 文字列用。
    void operator()(std::string& s) const {
        uint16_t length;// 長さは適当に型を選んで表現。
        (*this)(length);
        s = std::string(boost::asio::buffer_cast<const char*>(m_buf), length);
        m_buf = m_buf + length;
    }

    // vector用。
    template <typename T>
    void operator()(std::vector<T>& vs) const {
        const auto length = [this]{
            uint16_t l;
            (*this)(l);
            return l;
        }(); // Immediately-Invoked Function Expression(Thanks to JavaScript People!)

        vs.reserve(length);
        for(uint16_t i = 0; i < length; ++i){
            vs.emplace_back([this]{
                    T v;
                    (*this)(v);
                    return v;
                }());
        }
    }

    // Fusionで定義されたユーザ定義型用。ユーザ定義を入れ子にできる。
    template<class T>
    auto operator()(T & val) const
        -> typename std::enable_if<boost::fusion::traits::is_sequence<T>::value>::type {
        boost::fusion::for_each(val, *this);
    }
};

// read関数。
template <typename T>
std::pair<T, boost::asio::const_buffer>
read(boost::asio::const_buffer b){
    reader r(std::move(b));
    T res;
    boost::fusion::for_each(res, r); // 型Tの各メンバ・フィールドを反復。静的リフレクション。
    return {res, r.m_buf};
}

// -------------------------------- Serialize用 -------------------------------------------------
struct writer {
    mutable boost::asio::mutable_buffer m_buf;

    explicit writer(boost::asio::mutable_buffer buf) : m_buf(std::move(buf)) {}

    // 整数値用(uint32_t等)
    template <typename T>
    auto operator()(const T& val) const
        -> typename std::enable_if<std::is_integral<T>::value>::type {
        T tmp = hton(val);
        boost::asio::buffer_copy(m_buf, boost::asio::buffer(&tmp, sizeof(T)));// オブジェクトをバッファ(バイト列)として扱う。
        m_buf = m_buf + sizeof(T); // 書き込んだ分だけバッファのポインタをずらす。
    }

    // enum用。
    template <typename T>
    auto operator()(const T& val) const
        -> typename std::enable_if<std::is_enum<T>::value>::type {
        (*this)(underlying_type_cast(val));
    }

    // std::integral_constant用(コンパイル時整数値を表現する型)
    template <typename T, T v>
    void operator()(std::integral_constant<T, v>) const {
        (*this)(std::integral_constant<T, v>::value);
    }

    // Conceptを利用して広い範囲のクラスを対象とした関数を定義する。
    // Conceptとは、アルゴリズムに必要なシンタックスとシマンテックスを定義するための機構。
    // 特定の型TがConceptを満す場合、その型はConceptをモデルするという。
    // 以下の関数テンプレートで、Concept ForwardRangeをモデルする型ならシリアライズできる。
    // ForwardRangeをモデルする型の例: std::string、std::vector、etc。
    template <typename T>
    auto operator()(const T& vs) const
        -> typename std::enable_if<boost::has_range_const_iterator<T>::value>::type { // Concept: ForwardRange
        const auto length = std::distance(std::begin(vs), std::end(vs));
        if(length > std::numeric_limits<uint16_t>::max()) {
            throw std::runtime_error("length exceeds the range of uint16_t");
        }

        (*this)(static_cast<uint16_t>(length));
        for(const auto& v : vs){
            (*this)(v);
        }
    }

    // Fusionで定義されたユーザ定義型用。ユーザ定義を入れ子にできる。
    template<class T>
    auto operator()(T const& val) const ->
        typename std::enable_if<boost::fusion::traits::is_sequence<T>::value>::type {
        boost::fusion::for_each(val, *this);
    }
};

// write関数。
template <typename T>
boost::asio::mutable_buffer
write(boost::asio::mutable_buffer b, const T& val){
    writer w(std::move(b));
    boost::fusion::for_each(val, w);
    return w.m_buf;
}

// ---------------------------------- 直列化可能なユーザ定義型 ----------------------------------
// What we have achived?
// ここまで空行+コメント含めて184行。関数定義の平均は数行。
// 以下のようなユーザ定義型をシリアライズ・デシリアライズする能力。
//  - 整数型
//  - コンパイル時定数型
//  - 列挙型
//  - 文字列
//  - 可変長配列
//  - 上に列挙した型、または他のユーザ定義型のメンバ変数を持つユーザ定義型。

// マジック・バイトやバージョンは型で表現すれば良い!
namespace myapp{
    using magic_byte_t = std::integral_constant<uint32_t, 0x20>; // 1byteじゃないとダメなことに注意。
    using version_t    = std::integral_constant<uint32_t, 0x01>;

    enum class message_type : uint16_t {
        command,
        data,
    };

    enum class command_type : uint8_t {
        command_1,
        command_2,
    };
};

// struct myapp::headerの定義。
BOOST_FUSION_DEFINE_STRUCT(
    (myapp), // 名前空間。
    header, // ユーザ定義型の名前
    (myapp::magic_byte_t, magic_byte) // マジック・バイトを表現するassociated type。(メンバ変数じゃないよ!)
    (myapp::version_t, version) // バージョンを表現するassociated type。
    (uint16_t, length)
    (myapp::message_type, message_type)
    )

BOOST_FUSION_DEFINE_STRUCT(
    (myapp),
    command,
    (myapp::command_type, command_type)
    (std::vector<std::string>, args))

BOOST_FUSION_DEFINE_STRUCT(
    (myapp),
    data,
    (std::vector<char>, bytes)
    )

namespace myapp {// コンソール出力用関数。

    template <typename T, T v>
    std::ostream&
    operator<<(std::ostream& o, std::integral_constant<T, v>) {
        o << std::to_string(v);
        return o;
    }

    template <typename T>
    std::ostream&
    operator<<(std::ostream& o, const std::vector<T>& vs) {
        for(const auto& v: vs){
            o << v << ", ";
        }
        return o;
    }

    std::ostream&
    operator<<(std::ostream& o, const myapp::message_type& t){
        o << "message_type : ";
        switch(t){
        case myapp::message_type::command:
            o << "command";
            break;
        case myapp::message_type::data:
            o << "data";
            break;
        default:
            assert(false);
        }
        return o;
    }

    std::ostream&
    operator<<(std::ostream& o, const myapp::header& h){
        o << "magic_byte   : " << h.magic_byte << "\n";
        o << "version      : " << h.version    << "\n";
        o << "length       : " << h.length     << "\n";
        o << h.message_type;
        return o;
    }

    std::ostream&
    operator<<(std::ostream& o, const myapp::command_type& ct) {
        o << "command_type : ";
        switch(ct){
        case myapp::command_type::command_1:
            o << "command_1";
            break;
        case myapp::command_type::command_2:
            o << "command_2";
            break;
        default:
            assert(false);
        }
        return o;
    }

    std::ostream&
    operator<<(std::ostream& o, const myapp::command& c){
        o << c.command_type << "\n";
        o << c.args;
        return o;
    }

}

int main() {
    // 通信のシミュレーション
    std::array<char, 128> buf;

    { // 送信側
        myapp::header h;
        auto rest = write<myapp::header>(boost::asio::buffer(buf), h); // 固定長ヘッダ分だけ書き込み開始位置をずらす(ボディの長さが未定なため)。

        // 送信するコマンド。
        const auto com = []{
            myapp::command c;
            c.command_type = myapp::command_type::command_1;
            c.args.push_back("target 1");
            c.args.push_back("target 2");
            return c;
        }();
        rest = write<myapp::command>(rest, com); // シリアライズしてバッファに書き込む。

        h = [&buf, &rest]{
            myapp::header h;
            h.length = buf.size() - boost::asio::buffer_size(rest);
            h.message_type = myapp::message_type::command;
            return h;
        }();
        (void) write<myapp::header>(boost::asio::buffer(buf), h);
    }
    { // 受信側
        myapp::header h;
        boost::asio::const_buffer rest;
        std::tie(h, rest) = read<myapp::header>(boost::asio::buffer(buf));

        std::cout << "sizeof(h) : " << sizeof(h) << " bytes\n";
        std::cout << "Recieved header is\n";
        std::cout << h << "\n";

        myapp::command c;
        std::tie(c, rest) = read<myapp::command>(rest);
        std::cout <<"Recieved command is\n";
        std::cout << c << "\n";

        // ------------------- 実行結果 -------------------
        // sizeof(h) : 6 bytes
        // Recieved header is
        // magic_byte   : 32
        // version      : 1
        // length       : 35
        // message_type : command
        // Recieved command is
        // command_type : command_1
        // target 1, target 2,

        // ------------------- 質問 -----------------------
        // Q1. sizeof(h)が6 bytesなのは何故？
    }
    return 0;
}
