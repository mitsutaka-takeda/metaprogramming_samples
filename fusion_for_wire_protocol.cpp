// http://rodgert.github.io/2014/09/09/type-driven-wire-protocols-with-boost-fusion-pt1/
// https://github.com/rodgert/fusion_samples

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <arpa/inet.h>
#include <boost/asio/buffer.hpp>
#include <boost/fusion/include/for_each.hpp>

// ---------------------------------------------------------------------------
// ネットワーク・バイトからホスト・バイトへの変換。
template<class T> T ntoh(T) = delete; // white list方式。
uint32_t ntoh(uint32_t v) { return ntohl(v); }
uint16_t ntoh(uint16_t v) { return ntohs(v); }
uint8_t ntoh(uint8_t v) { return v; }
int8_t ntoh(int8_t v) { return v; }
char ntoh(char v) { return v; }

// ホスト・バイトからネットワーク・バイトへの変換。
template<class T> T hton(T) = delete;
uint32_t hton(uint32_t v) { return htonl(v); }
uint16_t hton(uint16_t v) { return htons(v); }
uint8_t hton(uint8_t v) { return v; }
int8_t hton(int8_t v) { return v; }
char hton(char v) { return v; }
// ----------------------------------------------------------------------------

struct reader {
    mutable boost::asio::const_buffer m_buf;

    explicit reader(boost::asio::const_buffer buf)
        : m_buf(std::move(buf))
        {}

    template <typename T>
    void operator()(T& val) const {
        // 型Tの各メンバ・フィールドを反復。
    }
};

template <typename T>
std::pair<T, asio::const_buffer>
read(asio::const_buffer b){
    reader r(std::move(b));
    T res;
    fusion::for_each(res, r); // 型Tの各メンバ・フィールドを反復。
    return {res, r.m_buf};
}

struct writer {
    mutable boost::asio::mutable_buffer m_buf;

    explicit writer(asio::mutable_buffer buf)
        : m_buf(std::move(buf))
        {}

    template <typename T>
    void operator()(const T& val) const {
    }
};

template <typename T>
boost::asio::mutable_buffer
write(boost::asio::mutable_buffer b, const T& val){
    writer w(std::move(b));
    boost::fusion::for_each(val, w);
    return w.m_buf;
}
